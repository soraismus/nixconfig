example                     effect
-------                     ------
"+yy                        copy the current line into the windowing system's clipboard
"*p                         paste the contents of the clipboard
@:                          repeat the most recent cmdmode command.
0w                          go to the first word
:let @/ = "hello, world"    set a register (specifically, here register "/)
{insert mode} <C-R>2        paste contents of register 2
{insert mode} <C-R>=        paste the evaluation of an expression in register "=
:lvimgrep /myFn/ **/*.c     search for pattern "myFn" in **/*.c files
:lopen                      open location list (containing files found by lgrep)
`adiw`bviwp`aP              swap words at marks `a and `b
"Ayw                        yank a word & append it into register "A
/<C-R>A                     put the contents of register "A into the search string
{normal mode} "+y{motion}   yank motion into the "+ register
{cmd mode}    :y%+          yank full file into the "+ register
:[line]put {register}       paste from register onto specified line
:[line]put! {register}      paste from register onto line before specified line
<C-W>T                      move current window to a new tab page
<C-W>t                      go to top page
<C-W>H                      move current window to the far left (can change vsplit to h)
<C-W>K                      move current window to the very top (can change hsplit to v)
<C-W>R                      rotate windows upwards N times
<C-W>r                      rotate windows downwards N times
*                           Search for the [count]th (not 0) occurrence of the word
                            ... nearest the cursor.
#                           like * but backward
g*                          like * but don't put "\<", "\>" around word in "/ register.
                            ... this allows matches on partial words
:tabnew	                    opens tabpage after the current one
:.tabnew	                  same as above
:+tabnew	                  opens tabpage after the next tab page
:-tabnew	                  opens tabpage before the current one
:0tabnew	                  opens tabpage before the first one
:$tabnew	                  opens tabpage after the last one
:!mv % ${new_filename}      rename the current file

:command -nargs=1 -bang -complete=file Ren f <args>|w<bang>
                            rename the current buffer

:command -range -nargs=1 -complete=file Replace <line1>-pu_|<line1>,<line2>d|r <args>|<line1>d
                            replace a range with the contents of a file

:command! -range -nargs=0 Lines  echo <line2> - <line1> + 1 "lines"
                            count the number of lines in the range

:command -nargs=* Mycmd call Myfunc(<f-args>)
                            call a user function

register            purpose
--------            -------
"" (unnamed)        the default when otherwise unspecified; often also a copy
"*                  primary X11 selection
"+                  clipboard X11 selection
".                  most recent insert
"%                  name of current file
":                  most recent cmdmode line
"#                  name of the current window's alternate file
"= (expression)
"~ (drop)           dropped text from most recent drag'n'drop
"_ (black hole)     to prevent changes to the other registers' state
"/                  most recent search-pattern
"{\d}               history of yank/delete commands
"- (small delete)   most recent delete of length less than one line
"{[a-z]}            lowercase if to replace
"{[A-Z]}            uppercase if to append

:h quoteplus
------------
There are three X selections:
  primary   - represents the current visual selection
  secondary - ill-defined
  clipboard - cut/copy/paste

longer examples
---------------
  [1]
:let i = 1
qa
/^Paragraph #\d<CR>
0w
i
<c-r>=i<CR>
.<esc>
:let i = i + 1<CR>
q

  [2]
:function! LineNumber()
:  return substitute(v:thowpoint, '.*\D\(\d\+\).*', '\1', "")
:endfuntion
:command! LineNumber try | throw "" | catch | echo LineNumber() | endtry

  [3]
:function! Foo()
:  throw "foo"
:endfunction
:try
:  call Foo()
:catch /foo/
:  echo "foo"
:finally
:  echo "finally"
:endtry

  [4]
:function Allargs(command)
:   let i = 0
:   while i < argc()
:	  if filereadable(argv(i))
:	     execute "e " . argv(i)
:	     execute a:command
:      endif
:      let i = i + 1
:   endwhile
:endfunction
:command -nargs=+ -complete=command Allargs call Allargs(<q-args>)

  [5]
inoremap <expr> <C-L> nr2char(getchar())
inoremap <expr> <C-L>x "foo"

plugin examples
---------------

[tpope's commentary]

example                           purpose
-------                           -------
{normal mode} [count] gcc         comment/uncomment line
{normal mode} gc {motion}         comment/uncomment {motion}
{visual mode} gc                  comment/uncomment section
gc                                text object for a comment (operator-pending mode)
gcgc                              gc (comment/uncomment) + gc (text object)
ugc                               u (undo) + gc (text object)
{command mode} :[range]Commentary comment/uncomment range
