# Refer to a command's arguments by position.
# The following is equivalent to `echo a b c c b a a echo`.
$ echo a b c !#:3 !#:2 !#:1 !#:6 !#:0
a b c c b a a echo

# Rename files.
$ touch config.txt
# Note that `!$` refers to the last argument of the previous command.
$ mv !$ !#:1:s/txt/json # `mv config.txt config.json`

# Rename files.
$ touch config.txt
$ mv con[tab]
$ mv config.txt # Then in command mode, press 'b', 'yw', 'w', 'p'.
$ mv config.txt config.txt # Then edit the second argument as needed.

$ apropos rename

$ touch abc1 abc2 abc33 abc44 abc555
# The following renames every file with a name of the template /abc\d\b/.
$ rename abc abc00 abc? # mv abc1 abc001; mv abc2 abc002
# The following renames every file with a name of the template /abc\d\d\b/.
$ rename abc abc0 abc?? # mv abc33 abc033; mv abc44 abc044
# The effect of the preceding two commands is to change the set of files
# from {abc1,   abc2,   abc33,  abc44,  abc555}
# to   {abc001, abc002, abc033, abc044, abc555}.

# Remember to use `fzf` instead of `find . -name`.
# Globbing isn't supported.
# However, search for multiple substrings is supported.
# Also, ^ and $ are supported, and search inversion ! is also supported.
$ fzf
> abc ^def .ghi$ !xyz

$ fzf | xargs ls -l
$ vim -o `fzf`
$ history | fzf +s --tac  # `+s` == `--no-sort`

# Start vim in diff mode.
$ vim -d file0 file1 [file2 [file3...]]

--------------------------------------------------

The first two statements of your BASH script should beâ€¦
by Ashish on January 11, 2020
(https://ashishb.net/all/the-first-two-statements-of-your-bash-script-should-be/)

```shell
#!/usr/bin/env bash
set -euo pipefail
```

The first statement is a Mac, GNU/Linux, and BSD portable way of finding
the location of the bash interpreter.

The second statement combines
- `set -e` [`set -o errtrace`],
  which ensures that your script stops on first command failure.
  By default, when a command fails, bash executes the next command.
  Looking at the logs, you might feel that the script executed successfully
  while some commands might have failed.
- `set -u` [`set -o nounset`],
  which ensures that your script exits on first unset variable encountered.
  Otherwise, bash replaces the unset variables with empty default values.
- `set -o pipefail`,
  which ensures that if any command in a set of piped commands failed,
  the overall exit status is the status of the failed command.
  Otherwise, the exit status is the status of the last command.

$ dirs # Display the directory stack used by `pushd` and `popd` commands.
$ printenv # Print the values of all or specified environment variables.
$ git clone ... abc; cd abc/x/y/; git rev-parse --git-dir # .../abc/.git


Bash functions can be declared inside other bash functions.
For example,
```shell
function fn0 () {
  function fn1 () {
    echo "Hello, world."
  }
  fn1
}
```

See bash-it for completion and script examples.
