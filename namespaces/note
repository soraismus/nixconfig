# $FILE_ANNOTATIONS maps file IDs to annotations.
# Usage: note set <filename> <note1> [<note2>, ...]
set () {
  # The file ID of a file is its inode index.
  local file_id="$( get-file-id "$1" )"

  # After 'shift', $@ will comprise only the notes
  # provided at the command line.
  shift

  for note in "$@"; do
    echo "${file_id}" "${note}" >> "${FILE_ANNOTATIONS}"
  done
}

# Usage: note get <filename>
get () {
  if [ -z "${FILE_ANNOTATIONS}" ]; then
    echo "The variable FILE_ANNOTATIONS is empty."
    exit 1
  elif [ ! -e "${FILE_ANNOTATIONS}" ]; then
    echo "Creating annotation cache at (" "${FILE_ANNOTATIONS}" ")."
    touch "${FILE_ANNOTATIONS}"
  fi
  local file_id="$( get-file-id "$1" )"
  cat "${FILE_ANNOTATIONS}" | awk "/${file_id}/" | cut -d" " -f2-
}

# Writes to the console the annotations of the files in the current directory.
# The performance of this function is slow, so consider making the implementation
# more efficient.
check-directory () {
  local note
  for file in *; do
    note="$( get "${file}" )"
    if [ -n "${note}" ]; then

      # The '-e' option enables interpretation of backslash escapes, including '\n'.
      echo -e "${note}\n  <-- ${file}"
    fi
  done
  note="$( get "$PWD" )"
  if [ -n "${note}" ]; then
    echo -e "${note}\n <-- this directory"
  fi
}

get-file-id () {
  local file_id
  # The '-d' flag of '[' determines whether the file is a directory.
  # The '-d' flag of 'ls' lists directory entries rather than directory contents.
  # The '-i' flag prints the inode number for each file.
  # The '-L' flag dereferences symbolic links.
  if [ -d "$1" ]; then
    file_id="$( ls -diL "$1" | awk '{print $1}' )"
  else
    file_id="$( ls -iL "$1" | awk '{print $1}' )"
  fi
  echo "$file_id"
}

help () {
  awk '/\(\) {/ {print $1}' "$NAMESPACES/$NAMESPACE"
}
